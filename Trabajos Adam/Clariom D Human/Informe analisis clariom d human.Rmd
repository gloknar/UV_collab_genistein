---
title: "Análisis de microarrays _Clariom D Human_ en R"
author: "Adam Casas"
date: 'Compilado: `r format(Sys.Date(), "%d de %B del %Y")`'
output: 
  html_document:
    df_print: paged
    highlight: kate
    number_sections: yes
    theme: cerulean
    toc: yes
    toc_float: yes
---

```{r configuracion inicial, include=FALSE}
# Establecemos la configuración de los chunks
knitr::opts_chunk$set(echo = TRUE,
                      message = TRUE,
                      warning = FALSE,
                      tidy = F)

# Establecemos el directorio de trabajo de este informe
# knitr::opts_knit$set(root.dir = "C:/Users/Adam_/Desktop/microvesiculas - copia para trabajar/Resultados ClariomD_Human")


set.seed(1)
##################################################
#######        Encoded in UTF-8        ###########
##################################################
```

***

# Introducción

En este documento se muestra cómo analizar los archivos con extensión `.CEL` resultantes de secuenciar muestras biológicas en los microchips _Clariom D Human_ de Affymetrix. Llevaremos a cabo este análisis en R 3.6 con el paquete de Bioconductor `oligo` versión 1.50.0. La versión de Biocondcutor empleada es la 3.10.

![Microchip Clariom D Human y sus correspondientes reactivos](https://assets.thermofisher.com/TFS-Assets/LSG/product-images/902922-650x600.jpg-650.jpg)

Fuente: https://wiki.bits.vib.be/index.php/Analyze_your_own_microarray_data_in_R/Bioconductor

y

https://www.thermofisher.com/es/es/home/life-science/microarray-analysis/microarray-data-analysis.html


<br>

***

# Carga de datos y librerías

Primero debemos instalar `oligo`. Téngase en cuenta que en R 3.6 se instala la versión 1.50.0 de `oligo`, el cual depende de los paquetes `ff` versión 2.2.14 y `RSQLite` versión 2.1.4. Instalar versiones posteriores ocasionará fallos en la carga de `oligo` y en los análisis posteriores:

```{r instalacion oligo y dependencias, eval = F}
# Instalación oligo en R 3.6:
BiocManager::install("oligo")

# Paquete ff versión 2.2.14:
install.packages("https://cran.r-project.org/src/contrib/Archive/ff/ff_2.2-14.tar.gz", 
                 repos=NULL, type = "source")

# Paquete RSQLite versión 2.1.4:
install.packages("https://cran.r-project.org/src/contrib/Archive/RSQLite/RSQLite_2.1.4.tar.gz",
                 repos=NULL, type = "source")
```


<br>

Comenzamos cargando `oligo`:

```{r carga librerias, message = F}
# Cargamos librerías
library("oligo")
library("ggplot2")
library("dplyr")
```

<br>

Acto seguido definimos el directorio de trabajo en la carpeta donde se encuentran los archivos de secuenciado.

```{r}
directorio_trabajo <- "./Archivos secuenciado/"
```


Listamos y cargamos los archivos de secuenciado en el objeto de tipo `HTAFeatureSet` denominado `datos_crudos_microarrays`. La carga de los archivos `.CEL` se hace mediante la función `read.celfiles`, la cual lee y carga los archivos por orden alfabético de sus nombres (_i.e._ primero carga el archivo `52CNT_(Clariom_D_Human).CEL`, luego `52GEN_(Clariom_D_Human).CEL`, luego `53CNT_(Clariom_D_Human).CEL`, ...etc):

```{r}
# Obtenemos la ruta completa de los archivos con el argumento `full.names = T`
ruta_completa_archivos_secuenciado <- list.files(path = directorio_trabajo, pattern = "*.CEL", full.names = T)

# Cargamos datos
datos_crudos_microarrays <- read.celfiles(filenames = ruta_completa_archivos_secuenciado)

# Observamos el tipo de objeto que hemos cargado
summary(datos_crudos_microarrays)

# Observamos las sondas y muestras que tenemos
dim(datos_crudos_microarrays)
```

```{r, echo = F, eval = F}
# Con el comando str() podemos ver la estructura general y bolsillos del objeto
# `datos_crudos_microarrays`, pero no lo ejecutaremos para no llenar de
# información la terminal:
str(datos_crudos_microarrays)
```


Podemos ver el nombre de los microchips con el comando `sampleNames()`.

```{r}
sampleNames(datos_crudos_microarrays)
```

Vamos a cambiar sus nombres por otros más claros:

```{r}
sampleNames(datos_crudos_microarrays) <- c("Control_1", "Genisteina_1",
                                           "Control_2", "Genisteina_2",
                                           "Control_3", "Genisteina_3",
                                           "Control_4", "Genisteina_4")
sampleNames(datos_crudos_microarrays)
```

<br>

Al cargar los archivos `.CEL` con `read.celfiles()`, se almacena en el bolsillo `datos_crudos_microarrays@assayData$exprs` la matriz de intensidades crudas de los fluoróforos que hibridan con las distintas sondas de cada microarray. Esta matriz tiene tantas filas como sondas tiene el microarray, y tantas columnas como muestras hayamos secuenciado. Las funciones `exprs()` e `intensity()` del paquete `oligo` simplifican el acceso a la misma (ambas funciones devuelven exactamente el mismo _output_).

* Las filas corresponden a cada sonda individual del microarray, identificada por un nº que va desde el 1 hasta el nº máximo de sondas presentes en el mismo (en el caso de los microarrays _Clariom D Human_, estos contienen un máximo de 6.892.960 sondas).

* Las columnas son las muestras, en nuestro caso `Control_1`, `Genisteina_1`, `Control_2`... etc

```{r}
# Obtenemos la matriz de intensidades cruda
intensidades <- oligo::exprs(datos_crudos_microarrays)

# Identificamos el nº de sondas presentes en cada microchips
dim(intensidades)[1]
```

<br>

Los microarrays de Affymetrix usan dos tipos de sondas: las PM (_Perfect Match_) y las MM (_MisMatch_). De acuerdo a [Flight _et al._](http://rmflight.github.io/affyMM/), las sondas PM contienen la secuencia complementaria exacta del transcrito con el que hibridan, mientras que las sondas MM contienen un nucleótido erróneo exactamente en la mitad de la sonda.

Para acceder a las intensidades de las sondas PM, podemos usar el comando `pm()` de `oligo`:

```{r}
sondas_PM <- oligo::pm(datos_crudos_microarrays)
head(sondas_PM)[,1:4]
```

<br>

De acuerdo a la documentación de [Affymetrix](https://www.affymetrix.com/support/help/exon_glossary/index.jsp#clusteroverview), las sondas de los microarrays de tipo Clariom D Human (Gene Arrays) están agrupadas en _transcription clusters_ en vez de _probesets_.

Con el comando `probeNames()` obtenemos los _transcription clusters_ a los que pertenecen las sondas de nuestro microchip, de manera que la primera sonda del microarray pertenece al _transcription cluster_ TC1300007722.hg.1: 

```{r}
# Obtenemos y mostramos los transcription clusters a los que pertenece cada sonda
transcription_clusters <- probeNames(datos_crudos_microarrays)
head(transcription_clusters)

# Cada microarray de tipo Clariom D Human contiene 1.220.891 transcription
# clusters
length(transcription_clusters)

# Obtenemos las sondas que pertenecen al transcription cluster TC1300007722.hg.1
which(transcription_clusters == "TC1300007722.hg.1")
```

<br>

Si tenemos cuenta en la página web de ThermoFisher, podemos usar el centro de análisis NetAffx para obtener más información sobre dichos clusters. Por ejemplo, si nos fijamos en el segundo _transcription cluster_, [TC0300011139.hg.1](https://www.affymetrix.com/analysis/netaffx/exon/hta_transcript.affx?pk=778:TC0300011139.hg.1), vemos que las sondas de este cluster detectan la presencia/ausencia de expresión del pseudogen RNA5SP132 (identificador [Ensembl:ENSG00000201595](http://www.ensembl.org/Homo_sapiens/Gene/Summary?g=ENSG00000201595;r=3:51694465-51694582;t=ENST00000364725)). 


```{r, echo = F, eval = F}
which(transcription_clusters == "TC1300007722.hg.1") # me devuelve 6 de 6 sondas

which(transcription_clusters == "TC0300011139.hg.1") # me devuelve 10 de 12 sondas

which(transcription_clusters == "TC1600006939.hg.1") # me devuelve 6 de 8 sondas

which(transcription_clusters == "TC0100018028.hg.1") # me devuelve 10 de 12 sondas

which(transcription_clusters == "TC0500010071.hg.1") # me devuelve 10 de 12 sondas

which(transcription_clusters == "TC1900010290.hg.1") # me devuelve 10 de 16 sondas
```



<br>

Además, el paquete `Biobase` incluye también numerosas funciones que se pueden ejecutar sobre los objetos de tipo `HTAFeatureSet` para obtener informacion contenida en el mismo, tales como abstracts, anotaciones, ...etc.

```{r}
# Anotación usada para nuestro objeto `HTAFeatureSet`
Biobase::annotation(datos_crudos_microarrays)

# Acceder a los datos del experimento del objeto `HTAFeatureSet` (en nuestro
# caso no está anotado)
Biobase::experimentData(datos_crudos_microarrays)
```


<br>

En relación a lo dicho en el párrafo anterior, las gráficas que generemos a lo largo del protocolo de análisis pueden usar información ubicada en el bolsillo `datos_crudos_microarrays@phenoData@data`, por lo que podemos añadir metadatos de interés con el comando `pData()` de `Biobase` tal que así:

```{r}
# Renombramos la columna "index" a "muestra"
colnames(pData(datos_crudos_microarrays)) <- "muestra"

# Añadimos el factor "Condición" a los metadatos de nuestro estudio
pData(datos_crudos_microarrays)$condicion <- as.factor(rep(c("Control", "Genisteina"), times = 4))

# Visualizamos los metadatos
pData(datos_crudos_microarrays)
```

<br>

***

# SECCIÓN EXPERIMENTAL!!!!!!!!

## Histogramas

```{r}
library("Rtsne")
??Rtsne
head(intensidades)
normalizado_tsne <- normalize_input(t(intensidades))
tsne <- Rtsne(X = normalizado_tsne, perplexity = 2)
plot(tsne$Y, col = c("red", "blue")); legend(-450, 500, legend = c("Control", "Genisteína"), col = c("red", "blue"), pch = 1)





library("umap") # Usar paquete uwot?
umap::umap(intensidades)
library(FactoMineR)
FactoMineR::PCA(intensidades)
head(t(intensidades))

# Con bucle for
for (i in pData(datos_crudos_microarrays)$muestra) {
hist(datos_crudos_microarrays[,i], transfo = log2, which = "all", 
     col = "black", ylab = "Densidad", xlab = "Intensidad (log2)",
     main = rownames(pData(datos_crudos_microarrays))[i], xlim = c(3.9, 14))
}


# Con lapply (tarda 2 segundos menos)
histogramas <- lapply(
  seq(1,8), # tenemos 8 muestras
  function(i) hist(datos_crudos_microarrays[,i], transfo = log2, which = "all", 
     col = "black", ylab = "Densidad", xlab = "Intensidad (log2)",
     main = rownames(pData(datos_crudos_microarrays))[i], xlim = c(3.9, 14)))
```




```{r, echo = F, eval = F}
tiempo_for <-  system.time(for (i in pData(datos_crudos_microarrays)$muestra) {
hist(datos_crudos_microarrays[,i], transfo = log2, which = "all", 
     col = "black", ylab = "Densidad", xlab = "Intensidad (log2)",
     main = rownames(pData(datos_crudos_microarrays))[i], xlim = c(3.9, 14))
})

tiempo_lapply <- system.time(lapply(
  seq(1,8), # tenemos 8 muestras
  function(i) hist(datos_crudos_microarrays[,i], transfo = log2, which = "all", 
     col = "black", ylab = "Densidad", xlab = "Intensidad (log2)",
     main = rownames(pData(datos_crudos_microarrays))[i], xlim = c(3.9, 14))))
```




jejeje



```{r}
# Distribucion intensidades sondas de todos los arrays con graphics
colores <- rep(c("green", "red"), each = 4)

hist(datos_crudos_microarrays[,1:8], lwd=2, which = "all", 
     col= colores, ylab="Densidad", xlab= "Intensidad(log2)",
     main = "Distribución de densidad de intensidades de sondas")
```


```{r}
# REVISAR EL CODIGO ORIGINAL

# Distribucion intensidades sondas de todos los arrays con ggplot2
sampleNames = rownames(pData(datos_crudos_microarrays))
logs = vector()
for (i in sampleNames) {
  logs = c(logs,log2(sondas_PM[,i]))
}
logs


logData = data.frame(logInt=logs,sampleName=sampleNames)

dataHist2 = ggplot(logData, aes(logInt, colour = sampleName)) 
dataHist2 + geom_density()
# Refactorizar y comentar este codigo...
```

  
## Analisis efecto lote

Para analizar el efecto lote, podemos usar las fechas en las que se hicieron.

```{r}
# analisis efecto lote!
affyio::get.celfile.dates(ruta_completa_archivos_secuenciado)

```

## QC

```{r}
# Control qc, por ahora puedo usar el TAC, pero me gustaria poder hacerlo aquí



```


##  background subtraction, normalization and summarization using median-polish (RMA)

```{r}
datos_crudos_microarrays <- oligo::rma(datos_crudos_microarrays)

datos_crudos_microarrays@phenoData
pData(datos_crudos_microarrays)
View(fData(datos_crudos_microarrays))
varMetadata(datos_crudos_microarrays)
umap(datos_crudos_microarrays@assayData$exprs)

preproc(object)
show(object)



data.rma = oligo::rma(datos_crudos_microarrays)
data.matrix = exprs(data.rma)

library("umap")
cosa <- umap::umap(iris[,1:4])
cosa
plot

iris
data(iris)
iris
pcaMethods::pca(t(data.matrix))
FactoMineR::plot.PCA(pca)
pca <- FactoMineR::PCA(t(data.matrix), axes = c(1:3))
pca$ind

library(rgl)
plot3d(pca$ind$coord[,1:3])

pca$ind$coord$color <- c(rep(c("red", "blue"), times = 4))


pca$ind

```

## Podria añadir parallel backend

mirar documentacion oligo

```{r}
library(ff)
library(foreach)
library(doMC)
registerDoMC(2)
library(oligo)


rma(datos_crudos_microarrays)
```


***

<br>


## Diagramas Venn


https://www.datanovia.com/en/blog/venn-diagram-with-r-or-rstudio-a-million-ways/
paquetes ggvenn o ggVennDiagram

***

<br>


# Bibliografía

* PlaceHolder



***

<br>


# sessionInfo()

```{r, echo = F}
sessionInfo()
```
